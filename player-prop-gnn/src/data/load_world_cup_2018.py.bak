"""
Database loader for World Cup 2018 data.
Loads StatsBomb data into PostgreSQL database following the schema.
"""
import sys
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
from pathlib import Path
import logging

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from statsbomb_loader import StatsBombLoader
from src.data.validation import (
    validate_player_data,
    validate_match_data,
    validate_player_match_stats,
    ValidationError
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DatabaseLoader:
    """Load StatsBomb data into PostgreSQL database"""
    
    def __init__(self, db_config: dict):
        """
        Initialize database connection.
        
        Args:
            db_config: Dict with keys: host, port, database, user, password
        """
        self.db_config = db_config
        self.conn = None
        self.cursor = None
        
    def connect(self):
        """Establish database connection"""
        logger.info(f"Connecting to database: {self.db_config['database']}")
        self.conn = psycopg2.connect(**self.db_config)
        self.cursor = self.conn.cursor()
        logger.info("Database connection established")
    
    def close(self):
        """Close database connection"""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        logger.info("Database connection closed")
    
    def load_world_cup_2018(self):
        """
        Load complete World Cup 2018 dataset into database.
        
        Steps:
        1. Load teams
        2. Load players
        3. Load matches
        4. Load player match stats
        """
        try:
            self.connect()
            
            # Load data from StatsBomb
            loader = StatsBombLoader()
            data = loader.load_world_cup_2018()
            
            matches_df = data['matches']
            player_stats_df = data['player_stats']
            
            # Step 1: Load teams
            logger.info("Loading teams...")
            teams_loaded = self._load_teams(matches_df)
            logger.info(f"Loaded {teams_loaded} teams")
            
            # Step 2: Load players
            logger.info("Loading players...")
            players_loaded = self._load_players(player_stats_df)
            logger.info(f"Loaded {players_loaded} players")
            
            # Step 3: Load matches
            logger.info("Loading matches...")
            matches_loaded = self._load_matches(matches_df)
            logger.info(f"Loaded {matches_loaded} matches")
            
            # Step 4: Load player match stats
            logger.info("Loading player match stats...")
            stats_loaded = self._load_player_stats(player_stats_df)
            logger.info(f"Loaded {stats_loaded} player-match records")
            
            self.conn.commit()
            logger.info("All data committed to database successfully!")
            
            # Print summary
            self._print_summary()
            
        except Exception as e:
            logger.error(f"Error loading data: {e}")
            if self.conn:
                self.conn.rollback()
            raise
        finally:
            self.close()
    
    def _load_teams(self, matches_df: pd.DataFrame) -> int:
        """Load teams into database"""
        # Extract unique teams
        teams = set()
        for _, match in matches_df.iterrows():
            teams.add(match['home_team'])
            teams.add(match['away_team'])
        
        teams_data = [
            (team, 'FIFA World Cup')
            for team in sorted(teams)
        ]
        
        # Insert teams
        query = """
        INSERT INTO teams (name, league)
        VALUES %s
        ON CONFLICT (name) DO NOTHING
        RETURNING team_id
        """
        
        execute_values(self.cursor, query, teams_data, template="(%s, %s)")
        return len(teams)
    
    def _load_players(self, player_stats_df: pd.DataFrame) -> int:
        """Load players into database"""
        # Get unique players
        players = player_stats_df[['player_id', 'player_name', 'team_name', 'position']].drop_duplicates('player_id')
        
        loaded_count = 0
        
        for _, player in players.iterrows():
            # Get team_id
            self.cursor.execute(
                "SELECT team_id FROM teams WHERE name = %s",
                (player['team_name'],)
            )
            result = self.cursor.fetchone()
            
            if not result:
                logger.warning(f"Team not found: {player['team_name']}")
                continue
            
            team_id = result[0]
            
            # Map StatsBomb positions to our schema
            position = self._map_position(player.get('position', 'Midfielder'))
            
            # Validate player data
            player_data = {
                'name': player['player_name'],
                'position': position,
                'team_id': team_id
            }
            
            try:
                validate_player_data(player_data)
            except ValidationError as e:
                logger.warning(f"Validation failed for player {player['player_name']}: {e}")
                continue
            
            # Insert player
            query = """
            INSERT INTO players (name, position, team_id)
            VALUES (%s, %s, %s)
            ON CONFLICT DO NOTHING
            """
            
            self.cursor.execute(query, (
                player_data['name'],
                player_data['position'],
                player_data['team_id']
            ))
            
            loaded_count += 1
        
        return loaded_count
    
    def _load_matches(self, matches_df: pd.DataFrame) -> int:
        """Load matches into database"""
        loaded_count = 0
        
        for _, match in matches_df.iterrows():
            # Get team IDs
            self.cursor.execute(
                "SELECT team_id FROM teams WHERE name = %s",
                (match['home_team'],)
            )
            home_team_result = self.cursor.fetchone()
            
            self.cursor.execute(
                "SELECT team_id FROM teams WHERE name = %s",
                (match['away_team'],)
            )
            away_team_result = self.cursor.fetchone()
            
            if not home_team_result or not away_team_result:
                logger.warning(f"Teams not found for match {match['match_id']}")
                continue
            
            home_team_id = home_team_result[0]
            away_team_id = away_team_result[0]
            
            # Validate match data
            match_data = {
                'home_team_id': home_team_id,
                'away_team_id': away_team_id,
                'match_date': str(match['match_date'])
            }
            
            try:
                validate_match_data(match_data)
            except ValidationError as e:
                logger.warning(f"Validation failed for match {match['match_id']}: {e}")
                continue
            
            # Insert match
            query = """
            INSERT INTO matches (home_team_id, away_team_id, match_date, home_score, away_score, league)
            VALUES (%s, %s, %s, %s, %s, %s)
            ON CONFLICT DO NOTHING
            RETURNING match_id
            """
            
            self.cursor.execute(query, (
                home_team_id,
                away_team_id,
                match['match_date'],
                match.get('home_score'),
                match.get('away_score'),
                'FIFA World Cup'
            ))
            
            loaded_count += 1
        
        return loaded_count
    
    def _load_player_stats(self, player_stats_df: pd.DataFrame) -> int:
        """Load player match statistics into database"""
        loaded_count = 0
        validation_errors = 0
        
        for _, stats in player_stats_df.iterrows():
            try:
                # Get player_id from database
                self.cursor.execute(
                    "SELECT player_id FROM players WHERE name = %s",
                    (stats['player_name'],)
                )
                player_result = self.cursor.fetchone()
                
                if not player_result:
                    logger.debug(f"Player not found: {stats['player_name']}")
                    continue
                
                player_id = player_result[0]
                
                # Get match_id from database
                # Match on home/away teams and date
                self.cursor.execute("""
                    SELECT m.match_id 
                    FROM matches m
                    JOIN teams ht ON m.home_team_id = ht.team_id
                    JOIN teams at ON m.away_team_id = at.team_id
                    WHERE ht.name = %s AND at.name = %s AND m.match_date = %s
                """, (stats['home_team'], stats['away_team'], stats['match_date']))
                
                match_result = self.cursor.fetchone()
                
                if not match_result:
                    logger.debug(f"Match not found: {stats['home_team']} vs {stats['away_team']}")
                    continue
                
                match_id = match_result[0]
                
                # Validate stats
                stats_data = {
                    'player_id': player_id,
                    'match_id': match_id,
                    'goals': int(stats.get('goals', 0)),
                    'assists': int(stats.get('assists', 0)),
                    'shots_on_target': int(stats.get('shots_on_target', 0)),
                    'total_shots': int(stats.get('total_shots', 0)),
                    'yellow_cards': int(stats.get('yellow_cards', 0)),
                    'red_cards': int(stats.get('red_cards', 0)),
                    'minutes_played': int(stats.get('minutes_played', 0))
                }
                
                validate_player_match_stats(stats_data)
                
                # Insert stats
                query = """
                INSERT INTO player_match_stats (
                    player_id, match_id, goals, assists, shots_on_target, total_shots,
                    yellow_cards, red_cards, minutes_played, was_home
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON CONFLICT (player_id, match_id) DO UPDATE SET
                    goals = EXCLUDED.goals,
                    assists = EXCLUDED.assists,
                    shots_on_target = EXCLUDED.shots_on_target,
                    total_shots = EXCLUDED.total_shots,
                    yellow_cards = EXCLUDED.yellow_cards,
                    red_cards = EXCLUDED.red_cards,
                    minutes_played = EXCLUDED.minutes_played,
                    was_home = EXCLUDED.was_home
                """
                
                self.cursor.execute(query, (
                    player_id,
                    match_id,
                    stats_data['goals'],
                    stats_data['assists'],
                    stats_data['shots_on_target'],
                    stats_data['total_shots'],
                    stats_data['yellow_cards'],
                    stats_data['red_cards'],
                    stats_data['minutes_played'],
                    bool(stats.get('was_home', False))
                ))
                
                loaded_count += 1
                
            except ValidationError as e:
                validation_errors += 1
                logger.debug(f"Validation error: {e}")
                continue
            except Exception as e:
                logger.error(f"Error loading stats: {e}")
                continue
        
        if validation_errors > 0:
            logger.info(f"Skipped {validation_errors} records due to validation errors")
        
        return loaded_count
    
    def _map_position(self, statsbomb_position: str) -> str:
        """
        Map StatsBomb position to our schema positions.
        
        Args:
            statsbomb_position: StatsBomb position name
            
        Returns:
            One of: 'Forward', 'Midfielder', 'Defender', 'Goalkeeper'
        """
        position = str(statsbomb_position).lower()
        
        if any(x in position for x in ['forward', 'striker', 'wing', 'attacking']):
            return 'Forward'
        elif any(x in position for x in ['midfield', 'central']):
            return 'Midfielder'
        elif any(x in position for x in ['back', 'defender', 'defense']):
            return 'Defender'
        elif 'goalkeeper' in position or 'keeper' in position:
            return 'Goalkeeper'
        else:
            # Default to Midfielder if unclear
            return 'Midfielder'
    
    def _print_summary(self):
        """Print database summary statistics"""
        print("\n" + "="*60)
        print("DATABASE LOAD SUMMARY")
        print("="*60)
        
        # Teams
        self.cursor.execute("SELECT COUNT(*) FROM teams")
        team_count = self.cursor.fetchone()[0]
        print(f"Teams: {team_count}")
        
        # Players
        self.cursor.execute("SELECT COUNT(*) FROM players")
        player_count = self.cursor.fetchone()[0]
        print(f"Players: {player_count}")
        
        # Matches
        self.cursor.execute("SELECT COUNT(*) FROM matches")
        match_count = self.cursor.fetchone()[0]
        print(f"Matches: {match_count}")
        
        # Player stats
        self.cursor.execute("SELECT COUNT(*) FROM player_match_stats")
        stats_count = self.cursor.fetchone()[0]
        print(f"Player-Match Records: {stats_count}")
        
        # Sample stats
        self.cursor.execute("""
            SELECT 
                SUM(goals) as total_goals,
                SUM(assists) as total_assists,
                SUM(total_shots) as total_shots,
                SUM(yellow_cards) as yellow_cards,
                SUM(red_cards) as red_cards
            FROM player_match_stats
        """)
        stats = self.cursor.fetchone()
        
        print("\nEvent Statistics:")
        print(f"  Total Goals: {stats[0]}")
        print(f"  Total Assists: {stats[1]}")
        print(f"  Total Shots: {stats[2]}")
        print(f"  Yellow Cards: {stats[3]}")
        print(f"  Red Cards: {stats[4]}")
        
        # Top scorers
        print("\nTop 5 Scorers:")
        self.cursor.execute("""
            SELECT p.name, SUM(pms.goals) as goals
            FROM players p
            JOIN player_match_stats pms ON p.player_id = pms.player_id
            GROUP BY p.player_id, p.name
            ORDER BY goals DESC
            LIMIT 5
        """)
        
        for i, (name, goals) in enumerate(self.cursor.fetchall(), 1):
            print(f"  {i}. {name}: {goals} goals")
        
        print("="*60 + "\n")


def main():
    """Main entry point"""
    # Database configuration
    db_config = {
        'host': 'localhost',
        'port': 5432,
        'database': 'football_props',
        'user': 'medhanshchoubey',
        'password': 'password'
    }
    
    print("="*60)
    print("WORLD CUP 2018 DATA LOADER")
    print("="*60)
    print("\nThis script will load World Cup 2018 data into the database.")
    print("It will take 5-10 minutes to complete.\n")
    
    response = input("Continue? (y/n): ")
    if response.lower() != 'y':
        print("Aborted.")
        return
    
    try:
        loader = DatabaseLoader(db_config)
        loader.load_world_cup_2018()
        
        print("\n✅ World Cup 2018 data loaded successfully!")
        print("\nYou can now:")
        print("  1. Query the database: psql football_props")
        print("  2. Run Phase 2.3 tests")
        print("  3. Proceed to Phase 2.4 (Feature Engineering)")
        
    except Exception as e:
        print(f"\n❌ Error: {e}")
        print("\nTroubleshooting:")
        print("  1. Ensure PostgreSQL is running")
        print("  2. Ensure database 'football_props' exists")
        print("  3. Ensure tables are created (run create_tables.sql)")
        print("  4. Check database credentials in db_config")
        return 1
    
    return 0


if __name__ == '__main__':
    sys.exit(main())